import streamlit as st
from pathlib import Path
import time
from streamlit_autorefresh import st_autorefresh
from google.oauth2 import service_account
from google.cloud import storage
from google.api_core import retry
import logging
import mimetypes

# Configure logging
logging.basicConfig(level=logging.INFO)

# Initialize Google Cloud Storage functions
def initialize_gcs_client():
    """Initialize Google Cloud Storage client with credentials from Streamlit secrets."""
    try:
        credentials = service_account.Credentials.from_service_account_info(
            st.secrets["gcp_service_account"]
        )
        return storage.Client(credentials=credentials)
    except Exception as e:
        logging.error(f"Failed to initialize GCS client: {str(e)}")
        raise

def upload_to_gcs(file_data, file_name, folder_path=None):
    """Upload a file to Google Cloud Storage with retry logic and proper error handling."""
    try:
        bucket_name = st.secrets["gcs"]["bucket_name"]
        client = initialize_gcs_client()
        bucket = client.bucket(bucket_name)
        
        # Construct the full blob path if folder_path is provided
        blob_path = f"{folder_path}/{file_name}" if folder_path else file_name
        blob = bucket.blob(blob_path)
        
        # Set content type based on file extension
        content_type = mimetypes.guess_type(file_name)[0]
        if content_type:
            blob.content_type = content_type

        # Configure retry strategy
        upload_retry = retry.Retry(initial=1.0, maximum=60.0, multiplier=2.0)
        
        # Upload with retry logic
        if hasattr(file_data, 'seek'):
            file_data.seek(0)  # Reset file pointer
            blob.upload_from_file(file_data, retry=upload_retry)
        else:
            blob.upload_from_string(file_data, retry=upload_retry)

        st.success(f"File '{file_name}' successfully uploaded to Google Cloud Storage.")
        return True

    except Exception as e:
        error_message = f"Failed to upload file '{file_name}': {str(e)}"
        logging.error(error_message)
        st.error(error_message)
        return False

def validate_file(uploaded_file, max_size_mb=10):
    """Validate uploaded file before processing."""
    if uploaded_file is None:
        st.error("No file was uploaded.")
        return False
        
    file_size_mb = uploaded_file.size / (1024 * 1024)
    if file_size_mb > max_size_mb:
        st.error(f"File size exceeds {max_size_mb}MB limit.")
        return False
        
    if not uploaded_file.name.lower().endswith('.pdf'):
        st.error("Only PDF files are allowed.")
        return False
        
    return True

# Define the folder path where files will be saved locally
save_folder = Path("files")
save_folder.mkdir(exist_ok=True)

# Initialize session state variables
if "page" not in st.session_state:
    st.session_state.update({
        'timer_running': False,
        'start_time': None,
        'elapsed_time': 0,
        'exam_duration': 20,
        'answer_uploaded': False,
        'question_downloaded': False,
        'solution_downloaded': False,
        'time_up': False,
        'show_main': False,
        'download_question_clicked': False,
        'upload_answer_clicked': False,
        'download_solution_clicked': False,
        'page': 'login'
    })

def start_timer():
    st.session_state.timer_running = True
    st.session_state.start_time = time.time() - st.session_state.elapsed_time

def stop_timer():
    st.session_state.timer_running = False
    st.session_state.elapsed_time = time.time() - st.session_state.start_time
    if st.session_state.elapsed_time >= st.session_state.exam_duration:
        st.session_state.time_up = True

# Page 1: Login Page
if st.session_state.page == "login":
    st.title("Student Login")
    
    # Store form inputs in session state to persist across reruns
    if "form_data" not in st.session_state:
        st.session_state.form_data = {
            "name": "",
            "email": "",
            "class": 7,
            "test": "Test1"
        }

    # Create form inputs
    st.session_state.form_data["name"] = st.text_input("Student Name", value=st.session_state.form_data["name"])
    st.session_state.form_data["email"] = st.text_input("Email ID", value=st.session_state.form_data["email"])
    student_class = st.selectbox("Class", [7, 8, 9, 10, 11, 12], index=0)
    test_number = st.selectbox("Test Number", ["Test1", "Test2", "Test3"], index=0)

    if st.button("Submit"):
        # Validate inputs
        if not st.session_state.form_data["name"] or not st.session_state.form_data["email"]:
            if not st.session_state.form_data["name"]:
                st.error("Please enter your name")
            if not st.session_state.form_data["email"]:
                st.error("Please enter your email ID")
        else:
            # Update session state and move to main page
            st.session_state.name = st.session_state.form_data["name"]
            st.session_state.email = st.session_state.form_data["email"]
            st.session_state.class_ = f"Grade{student_class}"
            st.session_state.test = test_number
            st.session_state.page = "main"
            st.session_state.show_main = True
            start_timer()
            st.rerun()

# Page 2: Main Page
elif st.session_state.page == "main":
    st.title("Test Page")
    
    main_col, _, timer_col = st.columns([2, 1, 1])
    
    with main_col:
        # Section 1: Question Paper Download
        st.subheader("Download Question Paper")
        
        question_path = save_folder / st.session_state.class_ / st.session_state.test / "QuestionPaper" / "QuestionPaper.pdf"
        if question_path.exists():
            if st.download_button(
                label="DOWNLOAD QUESTION PAPER",
                data=question_path.read_bytes(),
                file_name="QuestionPaper.pdf",
                mime="application/pdf",
                disabled=st.session_state.download_question_clicked
            ):
                st.session_state.download_question_clicked = True
                if not st.session_state.question_downloaded:
                    st.session_state.question_downloaded = True
                    start_timer()

        else:
            st.error("Question paper not available.")

        # Calculate remaining time
        remaining_time = max(st.session_state.exam_duration - st.session_state.elapsed_time, 0)
        if remaining_time <= 0:
            st.session_state.time_up = True
            if st.session_state.timer_running:
                stop_timer()

        # Section 2: Answer Sheet Upload
        if not st.session_state.solution_downloaded:
            st.subheader("Upload Your Answer Sheet")
            
            upload_disabled = st.session_state.time_up or remaining_time <= 0 or st.session_state.upload_answer_clicked
            
            uploaded_file = st.file_uploader(
                "Choose a PDF file to upload your answer sheet", 
                type="pdf", 
                key="answer_upload",
                disabled=upload_disabled
            )
            
            if upload_disabled and not st.session_state.answer_uploaded:
                st.error("Time's up! Answer sheet uploads are no longer accepted.")
            
            if uploaded_file and not upload_disabled:
                if validate_file(uploaded_file):
                    student_name = st.session_state.name.replace(" ", "_")
                    filename = f"{student_name}_{st.session_state.class_}.pdf"
                    
                    # Create the folder path for GCS
                    folder_path = f"{st.session_state.class_}/{st.session_state.test}/AnswerSheets"
                    
                    # First upload to Google Cloud Storage
                    if upload_to_gcs(uploaded_file, filename, folder_path):
                        # Then save locally if GCS upload was successful
                        answer_path = save_folder / st.session_state.class_ / st.session_state.test / "AnswerSheets" / filename
                        
                        # Save locally only if file doesn't exist
                        if not answer_path.exists():
                            answer_path.parent.mkdir(parents=True, exist_ok=True)
                            with open(answer_path, "wb") as f:
                                uploaded_file.seek(0)
                                f.write(uploaded_file.getbuffer())
                            
                            # Stop timer after successful upload
                            stop_timer()
                            st.session_state.answer_uploaded = True
                            st.session_state.upload_answer_clicked = True

        # Section 3: Download Solutions
        if st.session_state.answer_uploaded:
            st.subheader("Download Solutions")
            
            solution_path = save_folder / st.session_state.class_ / st.session_state.test / "Solutions" / "Solutions.pdf"
            if solution_path.exists():
                if st.download_button(
                    label="DOWNLOAD SOLUTIONS",
                    data=solution_path.read_bytes(),
                    file_name="Solutions.pdf",
                    mime="application/pdf",
                    disabled=st.session_state.download_solution_clicked
                ):
                    st.session_state.solution_downloaded = True
                    st.session_state.download_solution_clicked = True
                    st.session_state.page = "thank_you"
                    st.rerun()

    # Timer display
    if st.session_state.question_downloaded and not st.session_state.answer_uploaded and not st.session_state.solution_downloaded:
        with timer_col:
            st.subheader("Exam Timer")
            
            if st.session_state.timer_running:
                st.session_state.elapsed_time = time.time() - st.session_state.start_time
            
            remaining_time = max(st.session_state.exam_duration - st.session_state.elapsed_time, 0)
            minutes = int(remaining_time // 60)
            seconds = int(remaining_time % 60)
            
            time_str = f"{minutes:02d}:{seconds:02d}"
            if remaining_time <= 10:
                st.markdown(f"<h2 style='color: red;'>⏱️ {time_str}</h2>", unsafe_allow_html=True)
            elif remaining_time <= 30:
                st.markdown(f"<h2 style='color: orange;'>⏱️ {time_str}</h2>", unsafe_allow_html=True)
            else:
                st.markdown(f"<h2>⏱️ {time_str}</h2>", unsafe_allow_html=True)
            
            if remaining_time <= 10 and st.session_state.timer_running:
                st.warning("⚠️ Less than 10 seconds remaining!")
            
            if remaining_time <= 0 and st.session_state.timer_running:
                stop_timer()
                st.error("Time's up! Answer sheet uploads are no longer accepted.")
    
    # Auto-refresh timer
    if st.session_state.timer_running and not st.session_state.answer_uploaded:
        st_autorefresh(interval=1000)

# Page 3: Thank You Page
elif st.session_state.page == "thank_you":
    st.title("THANK YOU")
    st.header(f"Thank you {st.session_state.name} for completing the test!")
    st.success("Your answer sheet has been submitted and solutions have been downloaded successfully.")